##
# Author: Vikram Sunkara 
# Brief: The functions to render the trajectories into microscope outputed images
##

import numpy as np 
import cv2
import pickle
import tifffile as tiff


def draw_points(x, y, cell_size=2, intensity=1200, image_pixs=200):
	"""
	Render a particle in to the image.


	Parameters
	----------
	
	x : float 
			x coordinate of the centre of the particle

	y : float
			y coordinate of the centre of the particle

	cell_size : int
			radius of the circle to be rendered

	intensity : int
			the intensity with which to render the circle

	image_pixs : int
			the width of the image in terms of pixels (currently the images are considered ot be square)

	Return
	------

	img : ndarray (uint16)  shape = (image_pixs, image_pixs) 
			a blank image with the particle rendered in

	"""

	img = np.zeros((image_pixs,image_pixs),dtype=np.uint16)
	cv2.circle(img,(x,y), cell_size, intensity, -1)
	return img

def add_noise(max_noise,image_pixs=200,smooth=False):
	"""
	Generate an image with white noise

	Parameters
	----------
	max_noise : uint16
				The maximum amount of noise to add to the images

	image_pixs : int
			the width of the image in terms of pixels (currently the images are considered ot be square)

	smooth : bool 
			If True, the image will be processed with a Gaussian Blur filter

	Return
	------

	img : ndarray (uint16)  shape = (image_pixs, image_pixs) 
			an image with white noise added

	"""

	noise = np.zeros((image_pixs,image_pixs),dtype=np.uint16)
	cv2.randn(noise,(0),(max_noise))
	if smooth :
		cv2.GaussianBlur(noise, (3, 3), 0)
	return noise

def plot_particles(X, Y, shift=25, scale=4, image_pixs=200, intensity=1200, proportion_of_noise=0.15):
	"""
	Render all the particles in a time slice

	Parameters
	----------

	X : ndarray (num_particles)
				The x coordinates for each of the particles

	Y : ndarray (num_particles)
				The x coordinates for each of the particles

	shift : int
				Shifting the centre of the trajectories form (0,0) to (shift, shift)

	scale : int
				Stretching the particle box to make more bins

	image_pixs : int 
				Number of pixels along each axis of the image

	intensity : uint16
				The intensity of the rendered particles

	proposition_of_noise: float (0,1)
				The proportion of the intensity which the noise should be within

	Return
	------

	img : ndarray (uint16)  shape = (image_pixs, image_pixs)
				Image with all the particle positions rendered in and the noise added


	"""
	
	# Shifting and stretching the particle positions to be rendered.
	X_adjusted = ((X+shift)*scale).astype(np.int)
	Y_adjusted = ((Y+shift)*scale).astype(np.int)

	# List to store all the particle renders
	dots = []

	# Iterate over all particles and render it.
	for i in range(len(X)):
		if (X_adjusted[i] < image_pixs)  and (Y_adjusted[i] < image_pixs):
			dots.append(draw_points(X_adjusted[i],Y_adjusted[i]) + add_noise(0.01*intensity)) # adding some minor noise to not make the signal a pure circle

	Dots = np.array(dots)
	return np.sum(Dots, axis=0) + add_noise(proportion_of_noise*intensity, smooth=True)


def Render_Trajecs(filename, save_name=None):
	"""	
	The main function which takes the trajectories generated by Trakectory_Generator.py and renders the particles.

	Parameters
	----------

	filename : str 
				The name of the pickle file outputed by Trajectory_Generator.py

	save_name : str (default: None)
				In case you want to save the output image under another name.


	"""
	print("Opening Trajectories: %s"%(filename))
	f = open("%s.pck"%(filename),"rb")
	stuff = pickle.load(f)
	f.close()

	X_es = stuff["X"]
	Y_es = stuff["Y"]

	Image_Stack = []

	# Iterate through each time and render each time slice.
	print(" Rendering Trajectories: %s"%(filename))
	for t in range(len(X_es)):
		Image_Stack.append(plot_particles(X_es[t],Y_es[t]))

	if save_name is None:
		save_name = filename

	# Save the image stack in to a tiff stack
	Tiff_Stack = np.array(Image_Stack,dtype=np.uint16)
	tiff.imsave("Simulated_%s_Tiff_Stack.tiff"%(save_name), Tiff_Stack)

	print("Images Saved. %s"%(save_name))

def play_Movie(filename):
	"""	
	For visual inspection. 
	The trajectories generated by Trakectory_Generator.py and renders the particles for live view.
	
	Parameters
	----------

	filename : str 
				The name of the pickle file outputed by Trajectory_Generator.py

	"""

	import pylab as pl

	f = open("%s.pck"%(filename),"rb")
	Image_Stack = pickle.load(f)
	f.close()

	pl.ion()
	pl.figure(1)

	for i in range(len(Image_Stack)):
		pl.clf()
		pl.imshow(Image_Stack[i])
		pl.pause(0.01)
		pl.draw()


if __name__ == '__main__':
	# Example of how to run the code.
	'''
	n_partices = 100
	
	### Single Diffsion Examples
	
	num_replicates = 5
	for i in range(num_replicates):
		name = "Sims_D_0p5_numPart_%d_run_%d_"%(n_partices,i+1)
		Render_Trajecs(name)
	'''

	### Mixed Diffsion Examples
	num_replicates = 10
	for i in range(num_replicates):
		name = "Multi_Sims_D_ALL_numPart_%d_run_%d_"%(99,i+1)
		Render_Trajecs(name)

	#Render_Trajecs(name)

